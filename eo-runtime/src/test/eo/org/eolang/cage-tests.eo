# The MIT License (MIT)
#
# Copyright (c) 2016-2024 Objectionary.com
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

+architect yegor256@gmail.com
+home https://github.com/objectionary/eo
+tests
+package org.eolang
+version 0.0.0

# Test.
# @todo #2931:30min Enable the tests: dataizes-encaged-object-lazily-third and
#  dataizes-encaged-object-not-lazily-first. The tests were disabled because current cage
#  implementation is wrong (see: https://github.com/objectionary/eo/issues/3057).
#  We need to enable them when cage is great again.
[] > encages-into-cage
  # Object with free attribute.
  [z] > a
  cage.new a > x
  eq. > @
    seq
      *
        x.encage
          a 7
        x.z
    7

# Test.
[] > does-not-avoid-infinite-loop
  cage.new > x
    if
  x' > copy
  try > @
    seq
      *
        x.encage
          if TRUE 1 0
        copy.it
        x.encage
          if TRUE copy 0
        x
    [e]
      QQ.io.stdout e > @
    TRUE

# Test.
[] > dataizes-encaged-object-not-lazily-first
  cage.new 0 > x
  cage.new int.plus > sum
  eq. > @
    seq
      *
        x.encage 42
        sum.encage
          x.as-int.plus 1
        x.encage 7
        sum
    8

# Test.
[] > dataizes-encaged-object-lazily-second
  cage.new 0 > x
  cage.new int.plus > sum
  eq. > @
    seq
      *
        x.encage 42
        sum.encage
          1.plus x
        x.encage 7
        sum
    8

# Test.
[] > dataizes-encaged-object-lazily-third
  cage.new 0 > x
  cage.new 0 > y
  cage.new int.plus > sum
  eq. > @
    seq
      *
        x.encage 42
        y.encage 7
        sum.encage
          x.as-int.plus y
        y.encage 13
        x.encage 4
        sum
    17

# Test.
[] > stores-abstract-object-into-cage
  eq. > @
    seq
      *
        cage.new > c
          []
            112 > @
        c.@
    112

# Test.
[] > multi-layer-volatility
  (memory 0).alloc > ma
  cage.new a > ca
  # Layer A.
  [] > a
    # Layer A.phi.
    [] > @
      # Layer A.phi.phi.
      [] > @
        # Layer A.phi.phi.phi.
        [] > @
          seq > @
            *
              ma.write (ma.as-int.plus 1)
              ma.as-int
  (memory 0).alloc > mb
  cage.new b > cb
  # Layer B.
  [] > b
    # Layer B.phi.
    [] > @
      # Layer B.phi.phi.
      [] > @
        # Layer B.phi.phi.phi.
        [] > @
          seq > z
            *
              mb.write (mb.as-int.plus 1)
              mb.as-int
  eq. > @
    seq
      *
        ca
        ca.plus 40
    seq
      *
        cb.z
        cb.z.plus 40

# Test.
[] > infinite-loop-check
  # Recursive sum object.
  [value] > pyint
    # Add.
    [y] > add
      pyint (^.value.plus y.value) > @
  cage.new pyint > x
  cage.new > tmp
    x.add
  eq. > @
    seq
      *
        x.encage
          pyint 0
        tmp.encage
          x.add (pyint 1)
        QQ.io.stdout
          tmp.value
        tmp.value
    1

# Test.
[] > catches-encaging-objects-of-different-formas
  cage.new 5 > cge
  seq > @
    *
      try
        cge.encage "Hello world"
        [e]
          cge.encage 10 > @
        nop
      cge.eq 10

# Check that cage stack leads to error. Just prints the error
# message if passes.
[] > catches-stack-overflow
  cage.new > cge
    int.plus
  try > @
    []
      seq > @
        *
          cge.write
            0.plus cge
          cge
          FALSE
    [stack-overflow-message]
      QQ.io.stdout > @
        stack-overflow-message
    FALSE

# Test.
[] > applies-after-retrieval
  # Func.
  [x] > func
    2.plus x > @
  cage.new func > c
  eq. > @
    c.it 5
    7
