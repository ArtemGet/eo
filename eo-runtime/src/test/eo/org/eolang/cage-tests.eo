# The MIT License (MIT)
#
# Copyright (c) 2016-2024 Objectionary.com
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

+architect yegor256@gmail.com
+home https://github.com/objectionary/eo
+tests
+package org.eolang
+version 0.0.0

# Test.
[] > encages-into-cage
  # Object with free attribute.
  [z] > a
  (cage a).new > x
  seq > @
    *
      x.encage
        a 7
      x.freed.z.eq 7

# Test.
[] > cage-copy-refers-to-the-same-object
  (cage int).new > x
  x' > copy
  seq > @
    *
      x.encage 42
      copy.freed.eq 42

# Test.
[] > dataizes-encaged-object-not-lazily-first
  (cage 0).new > x
  (cage int.plus).new > sum
  seq > @
    *
      x.encage 42
      sum.encage
        x.plus 1
      x.encage 7
      and.
        sum.freed.eq 8
        x.free

# Test.
[] > dataizes-encaged-object-lazily-second
  (cage int).new > x
  (cage int.plus).new > sum
  seq > @
    *
      x.encage 42
      sum.encage
        1.plus x
      x.encage 7
      and.
        sum.freed.eq 8
        x.free

# Test.
[] > dataizes-encaged-object-lazily-third
  (cage int).new > x
  (cage int).new > y
  (cage int.plus).new > sum
  seq > @
    *
      x.encage 42
      y.encage 7
      sum.encage
        x.plus y
      y.encage 13
      x.encage 4
      and.
        sum.freed.eq 17
        and.
          x.free
          y.free

# Test.
[] > stores-abstract-object-into-cage
  new. > c
    cage
      []
        112 > @
  c.freed.eq 112 > @

# Test.
[] > multi-layer-volatility
  (memory 0).alloc > ma
  (cage a).new > ca
  # Layer A.
  [] > a
    # Layer A.phi.
    [] > @
      # Layer A.phi.phi.
      [] > @
        # Layer A.phi.phi.phi.
        [] > @
          seq > @
            *
              ma.write (ma.as-int.plus 1)
              ma.as-int
  (memory 0).alloc > mb
  (cage b).new > cb
  # Layer B.
  [] > b
    # Layer B.phi.
    [] > @
      # Layer B.phi.phi.
      [] > @
        # Layer B.phi.phi.phi.
        [] > @
          seq > z
            *
              mb.write (mb.as-int.plus 1)
              mb.as-int
  and. > @
    eq.
      seq > s1!
        *
          ca
          ca.freed.plus 40
      seq > s2!
        *
          cb.z
          cb.freed.z.plus 40
    and.
      ma.free
      mb.free

# Test.
[] > infinite-loop-check
  # Recursive sum object.
  [value] > pyint
    # Add.
    [y] > add
      pyint (^.value.plus y.value) > @
  (cage pyint).new > x
  (cage x.add).new > tmp
  seq > @
    *
      x.encage
        pyint 0
      tmp.encage
        x.add (pyint 1)
      QQ.io.stdout
        tmp.value
      and.
        tmp.freed.value.eq 1
        x.free

# Test.
[] > catches-encaging-objects-of-different-formas
  (cage 5).new > cge
  seq > @
    *
      try
        cge.encage "Hello world"
        [e]
          cge.encage 10 > @
        nop
      cge.freed.eq 10

# Check that cage stack leads to error. Just prints the error
# message if passes.
[] > catches-stack-overflow-in-recursive-cage
  (cage int.plus).new > cge
  try > @
    []
      seq > @
        *
          cge.encage
            0.plus cge
          cge
          FALSE
    [stack-overflow-message]
      and. > @
        QQ.io.stdout
          stack-overflow-message
        cge.free
    FALSE

# Test.
[] > applies-after-retrieval
  # Func.
  [x] > func
    2.plus x > @
  (cage func).new > c
  and. > @
    eq.
      c.it 5
      7
    c.free
