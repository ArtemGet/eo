The following four principles stay behind the
apparatus we introduce:

\begin{itemize}
\item An \emph{object} is a collection of \emph{attributes},
which are uniquely named bindings to objects. An object
is an \emph{atom} if its implementation is provided by the runtime.

\item An object is \emph{abstract} if at least one of its attributes
is \emph{free}---isn't \emph{bound} to any object. An object
is \emph{closed} otherwise.
\emph{Abstraction} is the process of creating an abstract object.
\emph{Application} is the process of making a \emph{copy} of an abstract
object, specifying some or all of its free attributes with
objects known as \emph{arguments}. Application may lead to the
creation of a closed object, or an abstract one, if not all free
attributes are specified with arguments.

\item An object may \emph{decorate} another object by binding it
to the $\varphi$ attribute of itself. A decorator has its
own attributes and the attributes of its decoratee.

\item A special attribute $\delta$ may be bound to \emph{data},
which is a computation platform dependable entity not
decomposable any further.
\emph{Dataization} is a process of retrieving data from an object,
by taking what the $\delta$ attribute is bound to.
The dataization of an object at the highest level of composition
leads to the execution of a program.
\end{itemize}

The contributions made by our work include:
\begin{inparaenum}[1)]
  \item a new object calculus,
  \item a new programming language with its syntax and semantics formally explained,
  \item a translator from the new language to XML,
  and
  \item a translator from XML to Java.
\end{inparaenum}

The rest of the paper is dedicated to the discussion of the
syntax of the language we created based on the calculus,
the calculus itself, its semantics, and pragmatics.
In order to make it easier to understand, we start
the discussion with the syntax of the language, while the calculus
is derived from it. At the end of the paper we discuss the
key features of \eo{} and the differences between it and other
programming languages.
We also overview the work done by others in the area of
formalization of OOP.

