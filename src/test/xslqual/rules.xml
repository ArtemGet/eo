<?xml version="1.0" encoding="UTF-8"?>
<!--
The MIT License (MIT)

Copyright (c) 2016-2024 Objectionary.com

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
-->
<ruleset xmlns="http://gandhimukul.tripod.com/xslt/ruleset" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
  <rule name="DontUseDoubleSlashOperatorNearRoot">
    <message>
      Avoid using the operator // near the root of a large tree
	</message>
    <xpath>
      //(@match | @select)[starts-with(., '//')]
	</xpath>
    <priority>2</priority>
    <example>
      <!-- VIOLATION -->
      <xsl:variable name="x" select="//x/y/z"/>
      <!-- REPAIR -->
      <xsl:variable name="x" select="/a/b/x/y/z"/>
    </example>
  </rule>
  <rule name="DontUseDoubleSlashOperator">
    <message>
      Avoid using the operator // in XPath expressions
	</message>
    <xpath>
      //(@match | @select)[not(starts-with(., '//')) and contains(., '//')]
	</xpath>
    <priority>3</priority>
    <example>
      <!-- VIOLATION -->
      <xsl:variable name="x" select="/x/y//z"/>
      <!-- REPAIR -->
      <xsl:variable name="x" select="/x/y/u/v/z"/>
    </example>
  </rule>
  <rule name="SettingValueOfVariableIncorrectly">
    <message>
      Assign value to a variable using the 'select' syntax if assigning a string value
	</message>
    <xpath>
      //xsl:variable[(count(*) = 1) and (count(xsl:value-of) = 1)]
	</xpath>
    <priority>2</priority>
    <example>
      <!-- VIOLATION -->
      <xsl:variable name="x">
        <xsl:value-of select="a/b/c"/>
      </xsl:variable>
      <!-- REPAIR -->
      <xsl:variable name="x" select="a/b/c"/>
    </example>
  </rule>
  <rule name="EmptyContentInInstructions">
    <message>
      Don't use empty content for instructions like 'xsl:for-each' 'xsl:if' 'xsl:when' etc.
	</message>
    <xpath>
      //(xsl:for-each | xsl:if | xsl:when | xsl:otherwise)[(count(node()) = count(text())) and (normalize-space() = '')]
	</xpath>
    <priority>3</priority>
    <example>
      <!-- VIOLATION -->
      <xsl:for-each select="expr">

	  </xsl:for-each>
      <!-- REPAIR -->
      <xsl:for-each select="expr">
        <!-- some instructions -->
      </xsl:for-each>
    </example>
  </rule>
  <rule name="DontUseNodeSetExtension">
    <message>
      Don't use node-set extension function if using XSLT 2.0
	</message>
    <xpath>
      /xsl:stylesheet[@version = '2.0']//@select[contains(., ':node-set')]
	</xpath>
    <priority>2</priority>
    <example><![CDATA[
	  <!-- VIOLATION -->
	  <xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                      version="2.0">

      select="exslt:nodeset($x)//*"

      <!-- REPAIR -->
	  select="$x//*"
	  ]]></example>
  </rule>
  <rule name="RedundantNamespaceDeclarations">
    <message>
      There are redundant namespace declarations in the xsl:stylesheet element
	</message>
    <xpath>
	  /xsl:stylesheet[not(every $s in in-scope-prefixes(.)[not(. = 'xml' or . = '')] satisfies 
	  exists(//(*[not(xsl:stylesheet)] | @*[not(parent::xsl:*)] | @select[parent::xsl:*] 
	  | @as | @name[parent::xsl:*])[starts-with(name(), concat($s, ':')) or starts-with
	  (., concat($s, ':'))]))]
	</xpath>
    <priority>3</priority>
    <example>
	</example>
  </rule>
  <rule name="UnusedFunction">
    <message>
      Stylesheet functions are unused
	</message>
    <xpath>
	  //xsl:function[not(some $x in //(@match | @select) satisfies contains($x, @name))]
	</xpath>
    <priority>3</priority>
    <example>
	</example>
  </rule>
  <rule name="UnusedNamedTemplate">
    <message>
      Named templates in stylesheet are unused
	</message>
    <xpath>
	  //xsl:template[@name and not(@match)][not(//xsl:call-template/@name = @name)]
	</xpath>
    <priority>3</priority>
    <example>
	</example>
  </rule>
  <rule name="UnusedVariable">
    <message>
      Variable is unused in the stylesheet
	</message>
    <xpath>
      //xsl:variable[not(some $att in //@* satisfies contains($att, concat('$', @name)))]
	</xpath>
    <priority>3</priority>
    <example>
	</example>
  </rule>
  <rule name="UnusedFunctionTemplateParameter">
    <message>
      Function or template parameter is unused in the function/template body
	</message>
    <xpath>
      //(xsl:function | xsl:template)/xsl:param[not(some $x in ..//(node() | @*) satisfies contains($x, concat('$', @name)))]
	</xpath>
    <priority>2</priority>
    <example>
	</example>
  </rule>
  <rule name="TooManySmallTemplates">
    <message>
      Too many low granular templates in the stylesheet (10 or more)
	</message>
    <xpath>
      /xsl:stylesheet[count(//xsl:template[@match and not(@name)][count(*) &lt; 3]) &gt;= 10]
	</xpath>
    <priority>4</priority>
    <example>
	</example>
  </rule>
  <rule name="MonolithicDesign">
    <message>
      Using a single template/function in the stylesheet. You can modularize the code.
	</message>
    <xpath>
      /xsl:stylesheet[count(//xsl:template | //xsl:function) = 1]
	</xpath>
    <priority>3</priority>
    <example>
	</example>
  </rule>
  <rule name="OutputMethodXml">
    <message>
      Using the output method 'xml' when generating HTML code
	</message>
    <xpath>
      /xsl:stylesheet/xsl:output[@method = 'xml'][starts-with(//xsl:template[.//html or .//HTML]/@match, '/')]
	</xpath>
    <priority>3</priority>
    <example>
	</example>
  </rule>
  <rule name="NotUsingSchemaTypes">
    <message>
      The stylesheet is not using any of the built-in Schema types (xs:string etc.), when working in XSLT 2.0 mode
	</message>
    <xpath>
      /xsl:stylesheet[@version = '2.0'][not(some $x in .//@* satisfies contains($x, 'xs:'))]
	</xpath>
    <priority>5</priority>
    <example>
	</example>
  </rule>
  <rule name="UsingNameOrLocalNameFunction">
    <message>
      Using name() function when local-name() could be appropriate (and vice-versa)
	</message>
    <xpath>
      //@*[contains(., 'name(') or contains(., 'local-name(')]
	</xpath>
    <priority>5</priority>
    <example>
	</example>
  </rule>
  <rule name="FunctionTemplateComplexity">
    <message>
      The function or template's size/complexity is high. There is need for refactoring the code.
	</message>
    <xpath>
      //(xsl:template | xsl:function)[count(.//xsl:*) &gt; 50]
	</xpath>
    <priority>4</priority>
    <example>
	</example>
  </rule>
  <rule name="NullOutputFromStylesheet">
    <message>
      The stylesheet is not generating any useful output. Please relook at the stylesheet logic.
	</message>
    <xpath>
      //xsl:template[starts-with(@match, '/')][(count(*) = count(xsl:variable)) and (normalize-space(string-join(text(), '')) = '')]
	</xpath>
    <priority>2</priority>
    <example>
      <!-- VIOLATION -->
      <xsl:template match="/">
        <xsl:variable name="x">
          <!-- some instructions -->
        </xsl:variable>
      </xsl:template>
    </example>
  </rule>
  <rule name="UsingNamespaceAxis">
    <message>
      Using the deprecated namespace axis, when working in XSLT 2.0 mode
	</message>
    <xpath>
      //(@match | @select)[contains(., 'namespace::')][/xsl:stylesheet/@version = '2.0']
	</xpath>
    <priority>4</priority>
    <example>
	</example>
  </rule>
  <rule name="CanUseAbbreviatedAxisSpecifier">
    <message>
      Using the lengthy axis specifiers like child::, attribute:: or parent::node()
	</message>
    <xpath>
      //(@match | @select)[contains(., 'child::') or contains(., 'attribute::') or contains(., 'parent::node()')]
	</xpath>
    <priority>4</priority>
    <example>
	  1. For child axis, child:: axis specifier may be omitted
      2. When the attribute axis is used, attribute:: may be abbviated to @
	  3. The expression parent::node() may be shortened to ..
	</example>
  </rule>
  <rule name="UsingDisableOutputEscaping">
    <message>
      Have set the disable-output-escaping attribute to 'yes'. Please relook at the stylesheet logic. 
	</message>
    <xpath>
      //@disable-output-escaping[. = 'yes']
	</xpath>
    <priority>3</priority>
    <example>
	</example>
  </rule>
  <rule name="NotCreatingElementCorrectly">
    <message>
      Creating an element node using the xsl:element instruction when could have been possible directly
	</message>
    <xpath>
      //xsl:element[not(contains(@name, '$') or (contains(@name, '(') and contains(@name, ')')) or 
	  (contains(@name, '{') and contains(@name, '}')))]
	</xpath>
    <priority>3</priority>
    <example>
      <!-- VIOLATION -->
      <xsl:element name="test">
        <!-- some content -->
      </xsl:element>
      <!-- REPAIR -->
      <test>
        <!-- some content -->
      </test>
    </example>
  </rule>
  <rule name="AreYouConfusingVariableAndNode">
    <message>
      You might be confusing a variable reference with a node reference
	</message>
    <xpath>
	  //xsl:apply-templates[some $var in ancestor::xsl:template[1]//xsl:variable satisfies 
	  (($var &lt;&lt; .) and starts-with(@select, $var/@name))]
    </xpath>
    <priority>5</priority>
    <example>
      <xsl:variable name="pass1">
        <!--
          Some code for "Pass 1"
        -->
      </xsl:variable>
      <!-- VIOLATION -->
      <xsl:apply-templates select="pass1/foo"/>
      <!-- REPAIR -->
      <xsl:apply-templates select="$pass1/foo"/>
    </example>
  </rule>
  <rule name="IncorrectUseOfBooleanConstants">
    <message>
      Incorrectly using the boolean constants as 'true' or 'false'
	</message>
    <xpath>
      //@*[(contains(., 'true') and not(contains(., 'true()'))) or (contains(., 'false') and not(contains(., 'false()')))]
	</xpath>
    <priority>5</priority>
    <example>
	  Perhaps you need true() instead of 'true', and false() instead of 'false'.
	</example>
  </rule>
  <rule name="ShortNames">
    <message>
      Using a single character name for variable/function/template. Use meaningful names for these features.
	</message>
    <xpath>
      //(xsl:variable | xsl:template)[string-length(@name) = 1] | //xsl:function[string-length(substring-after(@name, ':')) = 1]
	</xpath>
    <priority>4</priority>
    <example>
      <!-- VIOLATION -->
      <xsl:variable name="x" select="'hello'"/>
    </example>
  </rule>
  <rule name="NameStartsWithNumeric">
    <message>
      The variable/function/template name starts with a numeric character
	</message>
    <xpath>
      //(xsl:variable | xsl:template)[(string-length(@name) &gt; 1) and matches(@name, '[0-9].+')] | //xsl:function[(string-length(substring-after(@name, ':')) &gt; 1) and matches(substring-after(@name, ':'), '[0-9].+')]
	</xpath>
    <priority>5</priority>
    <example>
      <!-- VIOLATION -->
      <xsl:variable name="1x" select="'hello'"/>
    </example>
  </rule>
</ruleset>
